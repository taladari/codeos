import { promises as fs } from 'node:fs'
import path from 'node:path'
import { applyDiffToDir } from './diff.js'
import { suggestAffectedFiles } from './impact.js'
import YAML from 'yaml'
export interface LLMMessage { role: 'system'|'user'|'assistant'; content: string }
export interface LLMDriverLike { name: string; generate(messages: LLMMessage[], opts?: { maxTokens?: number, timeoutMs?: number, retries?: number }): Promise<{ text: string }>} 

export type RoleName = 'planner'|'builder'|'verifier'|'reviewer'

export interface PlannerOutput { planPath: string }
export interface BuilderOutput { patches: { file: string, diff: string }[] }
export interface VerifierOutput { reports: { path: string }[]; sandboxPath: string; appliedFiles: string[] }
export interface ReviewerOutput { reviewPath: string }

async function findLatestBlueprint(root: string): Promise<{ title: string, path?: string, content?: string }>
{
  const bpDir = path.join(root, '.codeos', 'blueprints')
  try {
    const entries = await fs.readdir(bpDir)
    let latest: { p: string, m: number } | null = null
    for (const f of entries) {
      if (!f.endsWith('.md')) continue
      const p = path.join(bpDir, f)
      const st = await fs.stat(p)
      if (!latest || st.mtimeMs > latest.m) latest = { p, m: st.mtimeMs }
    }
    if (latest) {
      const data = await fs.readFile(latest.p, 'utf8')
      const first = data.split(/\r?\n/)[0] ?? ''
      const title = first.replace(/^#\s*/, '') || path.basename(latest.p, '.md').replace(/-/g, ' ')
      return { title, path: latest.p, content: data }
    }
  } catch {}
  return { title: 'Untitled Blueprint' }
}

async function readAnalyzerReport(root: string): Promise<any> {
  try { return JSON.parse(await fs.readFile(path.join(root, '.codeos', 'reports', 'analyze.json'), 'utf8')) } catch { return {} }
}

async function readConfig(root: string): Promise<any> {
  try { return YAML.parse(await fs.readFile(path.join(root, 'codeos.yml'), 'utf8')) } catch { return {} }
}

function slugify(title: string): string {
  return title.toLowerCase().trim().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-')
}

export async function runPlanner(root: string, provider?: LLMDriverLike): Promise<PlannerOutput> {
  const planDir = path.join(root, '.codeos', 'plan')
  await fs.mkdir(planDir, { recursive: true })
  const latest = await findLatestBlueprint(root)
  const planPath = path.join(planDir, 'Plan.md')
  const perBlueprintPath = latest.title ? path.join(planDir, `${slugify(latest.title)}.md`) : planPath
  const bp = await findLatestBlueprint(root)
  const cfg = await readConfig(root)
  const analyze = await readAnalyzerReport(root)
  const language = cfg?.project?.language ?? analyze?.language ?? 'typescript'
  const testRunner = analyze?.testRunner ?? 'vitest'
  let body: string
  if (provider) {
    const sys = { role: 'system', content: `You are Planner. Generate a concise Plan.md (<=200 lines) with sections: Goals, Constraints, Affected Files, Steps, Test Plan, Acceptance Criteria. Be specific and minimal. Respect project constraints: language=${language}, test_runner=${testRunner}. Use that stack only.` } as LLMMessage
    const usr = { role: 'user', content: `Blueprint:\n${bp.content ?? bp.title}` } as LLMMessage
    try {
      const res = await provider.generate([sys, usr], { maxTokens: 800, timeoutMs: 10000, retries: 1 })
      body = res.text
    } catch {
      body = ''
    }
  } else {
    body = ''
  }
  if (!body || !/Goals|Affected Files|Test Plan/i.test(body)) {
    body = `## Blueprint\n- Title: ${bp.title}\n\n## Goals\n- Outline minimal change to add greeter function and a test.\n\n## Constraints\n- TypeScript, Vitest.\n\n## Affected Files\n- packages/core/src/generated/greeter.ts (new)\n- packages/core/src/generated/greeter.test.ts (new)\n\n## Steps\n- Add greeter implementation.\n- Add unit test.\n\n## Test Plan\n- Run vitest; expect greeter() to return a non-empty string.\n\n## Acceptance Criteria\n- [ ] greeter.ts exists and exports greeter().\n- [ ] test passes locally.`
  }
  // Append suggested affected files from repo index
  try {
    const suggestions = await suggestAffectedFiles(root, bp.title)
    if (suggestions.length) {
      body += `\n\n## Suggested Affected Files (from repo)\n` + suggestions.map(s => `- ${s}`).join('\n')
    }
  } catch {}
  const header = `# Plan\n\n` 
  const meta = provider ? `Generated by: ${provider.name}\n\n` : ''
  // Trim to <= 200 lines
  const content = (header + meta + body.split(/\r?\n/).slice(0, 200).join('\n') + '\n')
  await fs.writeFile(planPath, content, 'utf8')
  if (perBlueprintPath !== planPath) {
    await fs.writeFile(perBlueprintPath, content, 'utf8')
  }
  return { planPath }
}

function extractFirstUnifiedDiff(text: string): string | null {
  const hasMarkers = /^(--- |\+\+\+ )/m.test(text)
  if (!hasMarkers) return null
  // Return only lines that look like unified diff blocks
  const lines = text.split(/\r?\n/)
  const out: string[] = []
  let inBlock = false
  let _sawMinus = false
  let _sawPlus = false
  for (const l of lines) {
    if (l.startsWith('--- ') || l.startsWith('+++ ') || l.startsWith('@@')) { inBlock = true; out.push(l); continue }
    if (inBlock) {
      if (l.startsWith('+') || l.startsWith('-') || l.startsWith(' ') || l === '') {
        out.push(l)
        if (l.startsWith('--- ')) _sawMinus = true
        if (l.startsWith('+++ ')) _sawPlus = true
      }
      else if (/^\S/.test(l)) break
    }
  }
  const joined = out.join('\n') + '\n'
  if (!/(^|\n)---\s/m.test(joined) || !/(^|\n)\+\+\+\s/m.test(joined)) return null
  return out.length ? joined : null
}

export async function runBuilder(root: string, provider?: LLMDriverLike): Promise<BuilderOutput> {
  const patchesDir = path.join(root, '.codeos', 'patches')
  await fs.mkdir(patchesDir, { recursive: true })
  const cfg = await readConfig(root)
  const analyze = await readAnalyzerReport(root)
  const language = cfg?.project?.language ?? analyze?.language ?? 'typescript'
  const testRunner = analyze?.testRunner ?? 'vitest'
  let diff: string | null = null
  if (provider) {
    const plan = await fs.readFile(path.join(root, '.codeos', 'plan', 'Plan.md'), 'utf8').catch(()=> '')
    const sys = { role: 'system', content: `You are Builder. Produce ONLY unified diff(s) with tests. No prose. Respect project constraints: language=${language}, test_runner=${testRunner}. Keep diffs minimal.` } as LLMMessage
    const usr = { role: 'user', content: `Plan:\n${plan}\n\nCreate minimal change with tests using ${language} and ${testRunner}.` } as LLMMessage
    try {
      const res = await provider.generate([sys, usr], { maxTokens: 1200, timeoutMs: 15000, retries: 1 })
      diff = extractFirstUnifiedDiff(res.text)
    } catch {
      diff = null
    }
    if (!diff) {
      // Second attempt: instruct explicit new file diff skeleton
      const hint = { role: 'user', content: `Output a valid unified diff adding a minimal ${language} file under packages/core/src/generated/ and a matching ${testRunner} test. Do not include anything except the diff.` } as LLMMessage
      try {
        const res2 = await provider.generate([sys, hint], { maxTokens: 800, timeoutMs: 12000, retries: 1 })
        diff = extractFirstUnifiedDiff(res2.text)
      } catch { /* ignore */ }
    }
  }
  if (!diff) {
    const implPath = 'packages/core/src/generated/greeter.ts'
    const testPath = 'packages/core/src/generated/greeter.test.ts'
    const impl = `export function greeter(name: string = 'world'): string {\n  return \\\`hello, \\\${name}\\\`\n}`
    const test = `import { describe, it, expect } from 'vitest'\nimport { greeter } from '../generated/greeter'\n\ndescribe('greeter', () => {\n  it('returns a greeting', () => {\n    expect(greeter('codeos')).toContain('codeos')\n  })\n})\n`
    diff = [
      `--- /dev/null`,
      `+++ a/${implPath}`,
      `@@`,
      ...impl.split(/\r?\n/).map(l => `+${l}`),
      `--- /dev/null`,
      `+++ a/${testPath}`,
      `@@`,
      ...test.split(/\r?\n/).map(l => `+${l}`)
    ].join('\n') + '\n'
  }
  if (diff.length > 50_000) throw new Error('Patch too large')
  const patchPath = path.join(patchesDir, '001_greeter.diff')
  await fs.writeFile(patchPath, diff, 'utf8')
  return { patches: [{ file: patchPath, diff }] }
}

export async function runVerifier(root: string, patches: { file: string, diff: string }[]): Promise<VerifierOutput> {
  const runDir = path.join(root, '.codeos', 'run', Date.now().toString())
  const sandbox = path.join(runDir, 'sandbox')
  await fs.mkdir(sandbox, { recursive: true })
  // Lightweight copy (skip node_modules/.git/.codeos)
  await copyDir(root, sandbox, ['node_modules', '.git', '.codeos'])
  let applied: string[] = []
  for (const p of patches) {
    const files = await applyDiffToDir(sandbox, p.diff)
    applied = applied.concat(files)
  }
  const reportsDir = path.join(root, '.codeos', 'reports')
  await fs.mkdir(reportsDir, { recursive: true })
  const lint = path.join(reportsDir, 'lint.json')
  const tests = path.join(reportsDir, 'tests.json')
  await fs.writeFile(lint, JSON.stringify({ ok: true, errors: 0 }, null, 2), 'utf8')
  await fs.writeFile(tests, JSON.stringify({ ok: true, passed: 0, failed: 0 }, null, 2), 'utf8')
  const applyReport = path.join(reportsDir, 'apply.json')
  await fs.writeFile(applyReport, JSON.stringify({ applied }, null, 2), 'utf8')
  return { reports: [{ path: lint }, { path: tests }, { path: applyReport }], sandboxPath: sandbox, appliedFiles: applied }
}

export async function runReviewer(root: string): Promise<ReviewerOutput> {
  const reviewDir = path.join(root, '.codeos', 'review')
  await fs.mkdir(reviewDir, { recursive: true })
  const reviewPath = path.join(reviewDir, 'PR_SUMMARY.md')
  let changed: string[] = []
  try {
    const apply = JSON.parse(await fs.readFile(path.join(root, '.codeos', 'reports', 'apply.json'), 'utf8'))
    changed = apply.applied?.map((p: string) => path.relative(root, p)) ?? []
  } catch {}
  const changes = changed.length ? changed.map(c => `  - ${c}`).join('\n') : '  - (see patches)'
  const content = `# Summary\n\n- Changes:\n${changes}\n- Gates: lint/tests (see .codeos/reports)\n- Risks: low\n- Checklist:\n  - [ ] Review diff size and scope\n  - [ ] Run locally in sandbox\n`
  await fs.writeFile(reviewPath, content, 'utf8')
  return { reviewPath }
}

async function copyDir(src: string, dest: string, skipNames: string[]): Promise<void> {
  const ents = await fs.readdir(src, { withFileTypes: true })
  await fs.mkdir(dest, { recursive: true })
  for (const e of ents) {
    if (skipNames.includes(e.name)) continue
    const s = path.join(src, e.name)
    const d = path.join(dest, e.name)
    if (e.isDirectory()) await copyDir(s, d, skipNames)
    else {
      try {
        const data = await fs.readFile(s)
        await fs.writeFile(d, data)
      } catch {}
    }
  }
}

